---
layout: post
title:  HashMap
date:   2019-08-22 14:30:00 +0800
categories: Java
tags: Java
published: true
---

* content
{:toc}

## å‰è¨€

HashMap æ˜¯å¼€å‘ä¸­å­˜å‚¨æ•°æ®ç»å¸¸ç”¨åˆ°çš„ä¸€ä¸ªç±»ï¼Œå¦‚æ— ç‰¹æ®Šæé†’æœ¬æ–‡åŸºäº java 7 æºç ä»‹ç»ã€‚

## å†…éƒ¨å­˜å‚¨

HashMap å®ç°äº†æ¥å£  Map<K,V>ï¼Œè¯¥æ¥å£çš„ä¸»è¦æ–¹æ³•ï¼š

* V put(K key, V value)
* V get(Object key)
* V remove(Object key)
* Boolean containsKey(Object key)

HashMap ä½¿ç”¨ä¸€ä¸ªå†…éƒ¨ç±»æ¥å­˜å‚¨æ•°æ®ï¼š Entry<K, V>ï¼Œè¯¥ç±»æ˜¯ä¸€ä¸ªç®€å•çš„ key-value é”®å€¼å¯¹ï¼ŒåŒæ—¶åŒ…å«ä¸¤ä¸ªé¢å¤–æ•°æ®ï¼š

* æŒ‡å‘ä¸‹ä¸€ä¸ª Entry çš„å¼•ç”¨ï¼Œä½¿å¾— HashMap èƒ½å¤ŸæŠŠå¤šä¸ª Entry åƒé“¾è¡¨ä¸€æ ·å­˜å‚¨èµ·æ¥ã€‚
* key çš„ hash å€¼ï¼Œè¯¥ hash å€¼ä¼šç»å¸¸ä½¿ç”¨ï¼Œå­˜å‚¨èµ·æ¥é¿å…å¤šæ¬¡è®¡ç®—ã€‚

```java
static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    int hash;
    Â·Â·Â·
}
```

HashMap å­˜å‚¨æ•°æ®çš„æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ æ˜¯ä¸€æ¡é“¾è¡¨(ä¹Ÿå«åšæ¡¶æˆ–è€…ç®±)ï¼Œé“¾è¡¨çš„èŠ‚ç‚¹å°±æ˜¯ Entryã€‚

![internal_storage_java_hashmap]({{'/styles/images/hashmap/internal_storage_java_hashmap.jpg' | prepend: site.baseurl}}){:width="610" height="200"}

æ•°ç»„çš„åˆå§‹é•¿åº¦ä¸º 16ï¼Œæ‰€æœ‰å…·æœ‰ç›¸åŒ hash å€¼çš„ key éƒ½æ”¾åœ¨åŒä¸€é“¾è¡¨ï¼ˆæ¡¶/ç®±ï¼‰ã€‚

å½“è°ƒç”¨ put(K key, V value) æˆ–è€… get(Object key) æ—¶ï¼Œå‡½æ•°ä¼šè®¡ç®—å‡º Entry åº”è¯¥è¿›å…¥çš„æ¡¶çš„ indexï¼Œç„¶åéå†æ•´ä¸ªé“¾è¡¨å¯»æ‰¾ç›¸åŒ key çš„ Entryï¼ˆä½¿ç”¨ key çš„ equals() æ–¹æ³•ï¼‰ã€‚
è°ƒç”¨ get()ï¼Œæ–¹æ³•è¿”å›ç›¸åº” Entry çš„ valueï¼ˆå‰ææ˜¯å­˜åœ¨ key ç›¸åŒçš„ Entryï¼‰ã€‚
è°ƒç”¨ put()ï¼Œå¦‚æœ Entry å­˜åœ¨åˆ™æ›´æ–° Entry çš„ value å€¼ï¼Œå¦åˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„ Entry å¹¶ç½®äºé“¾è¡¨çš„è¡¨å¤´ã€‚

ç”Ÿæˆæ¡¶çš„ index åŒ…å« 3 æ­¥ï¼š

* è·å– key çš„ hashcode
* äºŒæ¬¡ hashï¼Œé˜²æ­¢ä¸€ä¸ªæ¯”è¾ƒå·®çš„ hash å‡½æ•°æŠŠæ‰€æœ‰æ•°æ®éƒ½åˆ†åœ¨äº†åŒä¸€ä¸ªæ¡¶ã€‚
* å°†äºŒæ¬¡ hash åçš„ hash å€¼ä¸æ•°ç»„é•¿åº¦ï¼ˆå‡1ï¼‰è¿›è¡Œä½æ©ç ï¼ˆä¸è¿ç®—ï¼‰ï¼Œè¯¥æ“ä½œä¿è¯ index ä¸ä¼šè¶…å‡ºæ•°ç»„çš„ sizeã€‚

```java
// the "rehash" function in JAVA 7 that takes the hashcode of the key
static int hash(int h) {
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}

// the "rehash" function in JAVA 8 that directly takes the key
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

// the function that returns the index from the rehashed hash
static int indexFor(int h, int length) {
    return h & (length-1);
}
```

ä¸ºäº†ä½¿ index èƒ½å¤Ÿå‡åŒ€åˆ†å¸ƒåœ¨æ•°ç»„é‡Œï¼Œæ•°ç»„çš„é•¿åº¦å¿…é¡»ä¸º 2 çš„å¹‚æ¬¡æ–¹å³ 2^nã€‚  
å› ä¸º 2^n - 1 = 0x111Â·Â·Â·111ï¼ˆn ä¸ª 1ï¼‰ï¼Œè¿™æ ·è¿›è¡Œä¸è¿ç®—åå¾—åˆ°çš„ index æ‰èƒ½å¤Ÿä¿è¯åˆ†å¸ƒå‡åŒ€ã€‚

å‡è®¾æ•°ç»„é•¿åº¦ä¸æ˜¯ 2^nï¼Œæ¯”å¦‚é•¿åº¦ 17ï¼Œé‚£ä¹ˆå¯¹äºä»»ä½•çš„ hash å€¼å’Œ 17 - 1 = 16 = 0x10000 è¿›è¡Œä¸è¿ç®—ï¼Œindex ç»“æœè¦ä¹ˆä¸º 16ï¼Œè¦ä¹ˆä¸º 0ã€‚æ‰€æœ‰çš„æ•°æ®è¿‡äºé›†ä¸­åœ¨éƒ¨åˆ†æ¡¶ï¼Œå¯¼è‡´æ•°ç»„ä¸å¤Ÿå¹³è¡¡ï¼Œä¼šå¯¹ HashMap äº§ç”Ÿä¸¥é‡çš„æ•ˆç‡å½±å“ã€‚

## è‡ªåŠ¨æ‰©å®¹

### åŸºç¡€æ¦‚å¿µ

äº†è§£ HashMap æ‰©å®¹å‰éœ€è¦ç†è§£å‡ ä¸ªé‡è¦å±æ€§ï¼š

* capacity
* loadFactor
* threshold
* size

capacity å®¹é‡ï¼ŒæŒ‡æ•°ç»„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯æ¡¶/ç®±çš„ä¸ªæ•°ï¼›loadFactor è´Ÿè½½å› å­ï¼›threshold å®¹é‡é˜ˆå€¼ï¼›size æŒ‡ HashMap å­˜æ”¾çš„å…ƒç´ ä¸ªæ•°ã€‚  
å…¶ä¸­ï¼Œthreshold = capacity * loadFactorã€‚  
size è·Ÿéš HashMap å­˜æ”¾çš„å…ƒç´ ç›¸åº”å¢å‡ï¼Œå½“ size >= threshold æ—¶ï¼Œæ•°ç»„æ‰©å®¹ã€capacity å¤§å°ç¿»å€ã€‚

### æ‰©å®¹åŸå› 

å‰é¢æˆ‘ä»¬è¯´äº†ï¼ŒHashMap çš„å­˜å‚¨ç»“æ„æ˜¯æ•°ç»„+é“¾è¡¨ï¼Œå­˜æ”¾/è·å–å…ƒç´ åˆ†ä¸¤æ­¥ï¼Œç¬¬ä¸€æ­¥æ˜¯è·å–é€šè¿‡ hash å€¼å®šä½åˆ°æ•°ç»„çš„ indexï¼Œç¬¬äºŒæ­¥æ˜¯éå†å¯¹åº”çš„é“¾è¡¨æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨ç›¸åŒ hash å€¼å’Œ key å€¼çš„ Entryã€‚  
ç¬¬ä¸€æ­¥çš„æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼Œç¬¬äºŒæ­¥çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)ã€‚æ‰©å®¹å°±æ˜¯ç”¨ç©ºé—´æ¢æ—¶é—´ï¼Œå¢åŠ æ•°ç»„çš„å¤§å°ï¼Œå‡å°‘é“¾è¡¨çš„å¹³å‡é•¿åº¦ nï¼Œä½¿å¾— O(n) å˜å°ã€‚

### åˆå§‹å®¹é‡

HashMap çš„åˆå§‹å®¹é‡ä¸º 16ï¼Œåˆå§‹è´Ÿè½½å› å­ä¸º 0.75ã€‚HashMap æœ‰å¤šä¸ªæ„é€ å‡½æ•°å¯ä¾›è®¾ç½®è¿™äº›å±æ€§ï¼š

* public HashMap()
* public HashMap(int initialCapacity)
* public HashMap(int initialCapacity, float loadFactor)

æ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©ä¸€ä¸ªåˆé€‚çš„ initialCapacity å¯ä»¥ä½¿å¾— HashMap æ›´é«˜æ•ˆã€‚å¦‚æœ initialCapacity è¿‡å°ï¼Œä½¿ç”¨è¿‡ç¨‹ä¸­éœ€è¦ä¸æ–­æ‰©å®¹ï¼Œè€Œæ‰©å®¹ä¼šå¯¹æ‰€æœ‰å…ƒç´ è¿›è¡Œæ•´ä½“æ¬è¿ï¼Œå¼€é”€è¾ƒå¤§ã€‚å¦‚æœ initialCapacity è¿‡å¤§ï¼Œåˆ™å®¹æ˜“é€ æˆç©ºé—´æµªè´¹ã€‚

### å®¹é‡å¼ºè½¬

å‰é¢æåŠäº†å¦‚æœæ•°ç»„é•¿åº¦ä¸ä¸º 2^n ä¼šå¯¼è‡´æ•°ç»„å…ƒç´ åˆ†å¸ƒä¸å‡åŒ€ï¼Œ é‚£ä¹ˆå¦‚æœè®¾ç½®ä¸€ä¸ªå¤§å°åˆé€‚çš„ä¸”ä¸ç­‰äº 2^n çš„ initialCapacity ä¼šæœ‰é—®é¢˜å—ï¼Ÿ  
ä¸å¿…æ‹…å¿ƒï¼ŒHashMap çš„è®¾è®¡è€…æ—©å·²ç»è€ƒè™‘äº†è¿™ä¸ªé—®é¢˜ï¼Œå¦‚æœèµ‹å€¼çš„ initialCapacity ä¸ç­‰äº 2^nï¼Œåˆ™ä¼šè¢«å¼ºåˆ¶è½¬æ¢æˆä¸‹ä¸€ä¸ªæœ€è¿‘çš„ 2^nã€‚è½¬æ¢çš„æ–¹æ³•éå¸¸ç²¾å¦™ï¼Œè·Ÿ [LeetCode 1009](https://leetcode.com/problems/complement-of-base-10-integer/){:target="_blank"} çš„[è§£é¢˜æ€è·¯](https://leetcode.com/submissions/detail/229098473/){:target="_blank"}å¾ˆç›¸ä¼¼ã€‚

```java
private static int roundUpToPowerOf2(int number) {
    // assert number >= 0 : "number must be non-negative";
    return number >= MAXIMUM_CAPACITY
            ? MAXIMUM_CAPACITY
            : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;
}

public static int highestOneBit(int i) {
    // HD, Figure 3-1
    i |= (i >>  1);
    i |= (i >>  2);
    i |= (i >>  4);
    i |= (i >>  8);
    i |= (i >> 16);
    return i - (i >>> 1);
}
```

**Note:** HashMap åªæä¾›äº†æ‰©å®¹ï¼Œå¹¶æ²¡æœ‰ç¼©å®¹ã€‚

## key ä¸å¯å˜

ä¸ºä»€ä¹ˆæˆ‘ä»¬æ›´å€¾å‘äºä½¿ç”¨å­—ç¬¦ä¸²æˆ–è€…æˆ–è€…æ•´æ•°ä½œä¸º HashMap çš„ keyï¼Ÿ  
å› ä¸ºå­—ç¬¦ä¸²å’Œæ•´æ•°ä¸å¯å˜ã€‚ä½¿ç”¨è‡ªå®šä¹‰ä¸”å¯å˜çš„ Key classï¼Œå¯èƒ½ä¼šä¸¢å¤±å­˜åœ¨ HashMap å†…éƒ¨çš„æ•°æ®ã€‚

```java
public class MutableKeyTest {

    public static void main(String[] args) {

        class MyKey {
            Integer i;

            public void setI(Integer i) {
                this.i = i;
            }

            public MyKey(Integer i) {
                this.i = i;
            }

            @Override
            public int hashCode() {
                return i;
            }

            @Override
            public boolean equals(Object obj) {
                if (obj instanceof MyKey) {
                    return i.equals(((MyKey) obj).i);
                } else
                    return false;
            }

        }

        Map<MyKey, String> myMap = new HashMap<>();
        MyKey key1 = new MyKey(1);
        MyKey key2 = new MyKey(2);

        myMap.put(key1, "test " + 1);
        myMap.put(key2, "test " + 2);

        // modifying key1
        key1.setI(3);

        String test1 = myMap.get(key1);
        String test2 = myMap.get(key2);

        System.out.println("test1= " + test1 + " test2=" + test2);

    }

}
```

è¯¥æµ‹è¯•è¾“å‡ºç»“æœä¸ºï¼š`test1= null test2=test 2`  
HashMap åœ¨è°ƒç”¨ get(key) è·å–æ•°æ®çš„æ—¶å€™ï¼Œé€šè¿‡ equals() æ–¹æ³•æ¯”è¾ƒ key æ˜¯å¦ç›¸ç­‰ï¼Œæµ‹è¯•ä»£ç ä¸­çš„ key1 ä¿®æ”¹å±æ€§ä¹‹åä¸å†æ»¡è¶³ equals()ï¼Œæ•…æŸ¥è¯¢ä¸åˆ°ç»“æœï¼Œè¿”å› nullã€‚

## Java 8 æ”¹è¿›

### çº¢é»‘æ ‘

æ¡¶åŠ å…¥äº†çº¢é»‘æ ‘ï¼Œä¸å†æ˜¯åŸæ¥å•ä¸€çš„é“¾è¡¨ç»“æ„ã€‚å½“é“¾è¡¨å…ƒç´ å¤§äºç­‰äº 8 æ—¶ï¼Œé“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼›å½“çº¢é»‘æ ‘ç»“ç‚¹å°äºç­‰äº 6 æ—¶ï¼Œçº¢é»‘æ ‘è½¬æ¢ä¸ºé“¾è¡¨ã€‚  
çº¢é»‘æ ‘ä½¿å¾—åœ¨æ¡¶é‡ŒæŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦ç”±é“¾è¡¨çš„ O(n) å‡å°åˆ° O(log(n))ã€‚

![internal_storage_java8_hashmap]({{'/styles/images/hashmap/internal_storage_java8_hashmap.jpg' | prepend: site.baseurl}}){:width="554" height="266"}

### äºŒæ¬¡ hash

java 8 æ”¹è¿›äº†äºŒæ¬¡ hash å‡½æ•°ï¼Œç§»é™¤äº† java 7 çš„ hashSeedã€‚æ›´æœ‰åŠ©äºå…ƒç´ åœ¨æ•°ç»„å†…å‡åŒ€åˆ†å¸ƒæˆ–è€…æ‰§è¡Œæ•ˆç‡æ›´é«˜ï¼Ÿï¼ˆæ²¡æœ‰å®æµ‹ï¼Œä½†æ€»ä¸è‡³äºè¶Šæ”¹è¶Šå·®å§ï¼‰ã€‚

```java
// the "rehash" function in JAVA 7 that takes the hashcode of the key
static int hash(int h) {
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}

// the "rehash" function in JAVA 8 that directly takes the key
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

### capacity = 2^n

ä¸åŒäº java 7 çš„ roundUpToPowerOf2()ï¼Œjava 8 é‡å†™äº†è¯¥æ–¹æ³•ä¸”æ–°å‘½åä¸º tableSizeFor()ã€‚

java 7 å…ˆå°† capacity å‡ 1ï¼Œç„¶åå‘å·¦ç§»ä¸€ä½ï¼Œæœ€åè°ƒç”¨ Integer ç±»çš„å–æœ€é«˜ä½æ–¹æ³•(è¯¥æ–¹æ³•å…ˆå°† i æœ€é«˜ä½å³ç§»å¡«æ»¡æ‰€æœ‰ä½ä½ï¼Œæœ€åå°† i å‡å» i å³ç§»ä¸€ä½åçš„å€¼ä¾¿æ˜¯ i çš„æœ€é«˜ä½)ã€‚

java 8 åŒæ ·é‡‡ç”¨äº†ç§»ä½çš„æ€æƒ³ï¼Œä½†æ˜¯è¿›è¡Œäº†å°ä¼˜åŒ–ï¼Œå…ˆå°† capacity å‡ 1ï¼Œç„¶åç›´æ¥æœ€é«˜ä½å³ç§»å¡«æ»¡æ‰€æœ‰ä½ä½ï¼Œæœ€åå†åŠ ä¸€ã€‚

```java
// JAVA 7
private static int roundUpToPowerOf2(int number) {
    // assert number >= 0 : "number must be non-negative";
    return number >= MAXIMUM_CAPACITY
            ? MAXIMUM_CAPACITY
            : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;
}

public static int highestOneBit(int i) {
    // HD, Figure 3-1
    i |= (i >>  1);
    i |= (i >>  2);
    i |= (i >>  4);
    i |= (i >>  8);
    i |= (i >> 16);
    return i - (i >>> 1);
}

// JAVA 8
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

å‡è®¾ capacity = 23ï¼›2^4 < capacity < 2^5ï¼Œæ‰€ä»¥è½¬æ¢å capacity çš„æ­£ç¡®å€¼åº”è¯¥ä¸º 2^5 = 32ã€‚

java 7ï¼š  

1. capacity = 23ï¼ŒäºŒè¿›åˆ¶ä¸º 0x10111
2. capacity å‡ 1ï¼ŒäºŒè¿›åˆ¶ä¸º 0x10110
3. capacity å·¦ç§»ä¸€ä½ï¼ŒäºŒè¿›åˆ¶ä¸º 0x101100
4. capacity æœ€é«˜ä½çš„ 1 å¡«æ»¡æ‰€æœ‰ä½ä½ï¼ŒäºŒè¿›åˆ¶ä¸º 0x111111
5. capacity å‡å»æ— ç¬¦å·å³ç§»ä¸€ä½åçš„å€¼ï¼Œå³ 0x111111 - 0x011111 = 0x100000 = 32

java 8ï¼š

1. capacity = 23ï¼ŒäºŒè¿›åˆ¶ä¸º 0x10111
2. capacity å‡ 1ï¼ŒäºŒè¿›åˆ¶ä¸º 0x10110
3. capacity æœ€é«˜ä½çš„ 1 å¡«æ»¡æ‰€æœ‰ä½ä½ï¼ŒäºŒè¿›åˆ¶ä¸º 0x11111
4. capacity åŠ  1ï¼Œå³ 0x11111 + 0x1 = 0x100000 = 32

å¯ä»¥çœ‹åˆ°ï¼Œjava 8 çš„å°ä¼˜åŒ–ç†è®ºä¸Šä¼šæ›´å¿«ä¸€ç‚¹ç‚¹ï¼Œå‰è¾ˆä»¬è¿½æ±‚å®Œç¾çš„åŠªåŠ›ç¨‹åº¦ä»¤æˆ‘ç­‰æ±—é¢œğŸ˜“ã€‚

**Note**  
java 8 å°† Entry æ›´åä¸º Nodeï¼Œå¤§æ¦‚æ˜¯é…åˆçº¢é»‘æ ‘æ›´é¡ºå£å§ã€‚

## HashTable

### çº¿ç¨‹å®‰å…¨

HashMap ä¸é€‚åˆå¤šçº¿ç¨‹ä½¿ç”¨ï¼Œè¯•æƒ³ä¸€ä¸ªçº¿ç¨‹ put() çš„æ—¶å€™è§¦å‘äº†è‡ªåŠ¨æ‰©å®¹æœºåˆ¶ï¼Œè€Œè¿™æ—¶å¦å¤–ä¸€ä¸ªçº¿ç¨‹æ¥å–æ•°æ®åˆ™ä¼šæ‰¾ä¸åˆ°åŸæ¥ Entry æ‰€åœ¨çš„æ–°æ¡¶ã€‚

HashTable æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå› ä¸ºæ‰€æœ‰çš„ CRUD æ“ä½œéƒ½è¢« synchronized é”äº†èµ·æ¥ï¼Œä¹Ÿæ­£æ˜¯å¦‚æ­¤ HashTable æ•ˆç‡ä¼šä½å¾ˆå¤šã€‚

è‹¥æœ‰å¤šçº¿ç¨‹åº”ç”¨çš„åœºæ™¯ï¼Œä¸€ä¸ªæ›´å¥½çš„åŠæ³•æ˜¯ä½¿ç”¨ ConcurrentHashMapã€‚ConcurrentHashMap é‡‡ç”¨åˆ†æ®µé”ï¼Œåªè¦æ“ä½œä¸æ˜¯åœ¨åŒä¸€ä¸ªæ¡¶æˆ–è€…æ‰©å®¹å°±å¯ä»¥æ”¯æŒå¹¶å‘ã€‚

### capacity

ä¸ HashMap 2 çš„å¹‚æ¬¡æ–¹å®¹é‡ä¸åŒï¼ŒHashTable åˆå§‹å®¹é‡ä¸º 11ï¼Œæ¯æ¬¡æ‰©å®¹å®¹é‡ç¿»å€ä¸”åŠ  1ã€‚  
å®¹é‡ä¸ä¸º 2^n åï¼ŒHashTable ä½¿ç”¨å–ä½™æ“ä½œæ¥ä¿è¯å…ƒç´ å‡åŒ€åˆ†å¸ƒåœ¨æ•°ç»„é‡Œã€‚

```java
int index = (hash & 0x7FFFFFFF) % tab.length;
```

## æ€»ç»“

ç°åœ¨ä»å¤´å›é¡¾ä¸‹æ•´ä¸ª HashMap çš„è®¾è®¡ï¼š

å­˜ä¸€å †æ•°æ®æœ€ä½³çš„æ•°æ®ç»“æ„æ˜¯ä»€ä¹ˆï¼Ÿ  
æ˜¯æ•°ç»„ï¼Œæˆ–è€…è¯´çº¿æ€§è¡¨ã€‚è¿™ç§æ•°æ®ç»“æ„åœ¨å†…å­˜ä¸­åˆ†é…çš„æ˜¯ä¸€å—è¿ç»­çš„ç©ºé—´ï¼Œå¯ä»¥é€šè¿‡é¦–åœ°å€+åç§»é‡ï¼ˆä¸‹æ ‡ï¼‰çš„æ–¹å¼å¿«é€Ÿå®šä½ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(1)ã€‚

Hash æ˜¯ä»ä¸€ä¸ªæ— é™å…ƒç´ é›†åˆåˆ°ä¸€ä¸ªæœ‰é™å…ƒç´ é›†åˆçš„æ˜ å°„ï¼Œæ‰€ä»¥ç†è®ºä¸Šä¸€å®šä¼šå­˜åœ¨ hash å†²çªï¼Œç”¨ key çš„ hash å€¼æ¥ç¡®å®šæ•°ç»„ä¸‹æ ‡ä¹Ÿå°±æ„å‘³ç€æ•°ç»„çš„æ¯ä¸€ä¸ª item éƒ½å¯èƒ½å¯¹åº”å¤šä¸ªå…ƒç´ ã€‚äºæ˜¯å‡ºç°äº†æ•°ç»„+é“¾è¡¨çš„ç»„åˆå­˜å‚¨æ–¹å¼ã€‚

æ•°ç»„å®šä½çš„æ—¶é—´å¤æ‚åº¦ O(1)ï¼Œé“¾è¡¨éå†çš„æ—¶é—´å¤æ‚åº¦ O(n)ã€‚  
åœ¨æ•°ç»„å…ƒç´ åˆ†å¸ƒå‡è¡¡çš„æƒ…å†µä¸‹ï¼Œæ‰©å®¹å¯ä»¥é™ä½é“¾è¡¨çš„é•¿åº¦ nï¼Œä»è€Œå‡å°æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´æ¢æ—¶é—´ã€‚  
äºŒæ¬¡ hash ä¿è¯å…ƒç´ åœ¨æ•°ç»„å†…åˆ†å¸ƒæ›´å‡åŒ€ï¼Œå½“ç„¶å‰æå¿…é¡»æ˜¯ä¸€ä¸ªè¶³å¤Ÿå¥½çš„ rehash å‡½æ•°ã€‚  
å¼•å…¥çº¢é»‘æ ‘ä¹Ÿæ˜¯ä¸ºäº†å‡å°æ—¶é—´å¤æ‚åº¦ï¼Œä»é“¾è¡¨çš„ O(n) é™ä½åˆ° O(log(n))ã€‚
