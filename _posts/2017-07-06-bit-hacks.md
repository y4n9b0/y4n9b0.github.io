---
layout: post
title:  "Bit Hacks"
date:   2017-07-06 14:00:00 +0800
categories: Algorithm
tags: Bit&#160;Hacks
published: true
---

* content
{:toc}


# Prologue
先讲个笑话:这世界上有10种人,懂二进制的人和不懂二进制的人:smile:  
众所周知,计算机数据采用二进制形式存储,分别用高低电平表示1和0.  
在位运算之前,咱们先说原码、反码、补码.  

# Complement
* **原码**  
设机器字长为n,那么一个数的原码就是一个n位的二进制数.计算机为了区分正负数,将最高位设为符号位,正数为0,负数为1.  
正数的原码、反码、补码都一样.  
0分正0和负0,原码和反码有两个.

* **反码**  
对于负数,反码是在原码的基础上,保持符号位不变,其他位按位取反.

* **补码**  
同样只针对负数,补码是在反码的基础上加1.  
补码还可以这么理解,符号位不变,从低位开始,直到遇到第一个1,把该位以后(不含自身)的所有位都按位取反.  
但这样其实有个问题,负0的补码表示形式变了.就当作个加深理解的非正式技巧把.  
其实还有个**移码**,符号位取反的补码,不是你们家亲戚.  

为什么会有原码、反码、补码?  
由于原码分正负,在计算机设计之初,如果考虑让计算机辨别原码符号位进行运算,则会出现加法和减法,基础电路设计会变得十分复杂.先驱们就想办法把符号位一起纳入运算,减法变换成加法.  

反码的出现把硬件问题给转到软件上来,轻松解决了原码的减法问题.  
以机器字长n=8为例,计算十进制的表达式: 1-1=0  
1 - 1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub>= [0000 0001]<sub>反</sub> + [1111 1110]<sub>反</sub> = [1111 1111]<sub>反</sub> = [1000 0000]<sub>原</sub> = -0  

但是反码还是有个问题,0会有两种表达形式:正0和负0.  
于是补码出现了,解决了0的符号及两个编码问题  
1-1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub> = [0000 0001]<sub>补</sub> + [1111 1111]<sub>补</sub> = [0000 0000]<sub>补</sub>=[0000 0000]<sub>原</sub>

0的问题解决了,空出来的负0在补码里成了-2<sup>n</sup>  
(-1) + (-127) = [1000 0001]<sub>原</sub> + [1111 1111]<sub>原</sub> = [1111 1111]<sub>补</sub> + [1000 0001]<sub>补</sub> = [1000 0000]<sub>补</sub>  
所以补码在原码和反码的基础上表达范围还多出一个最小值 [-2<sup>n</sup>, 2<sup>n</sup>-1]  

# Bit Arithmetic
基本的位运算符.  
* **&** 按位与,注意与逻辑与或非的区别  
* **\|** 按位或  
* **^** 按位异或  
* **~** 取反
* **\<<** 左移,低位补0,高位溢出则舍弃高位  
* **\>>** 右移,负数高位补1,非负数高位补0  
* **\>>>** 无符号右移,高位补0  
C语言没有无符号右移,可用 `((unsigned int)x)>>1` 来实现.

# Bit Twiddling
**求平均数**  
先看一个经常被笔试的例子:求两个数x和y的平均数.  

很容易想到的答案是`(x+y)/2`.  
但是这个答案有个问题,x+y有溢出风险,于是一部分人在第一个答案的基础上优化了一下,演变成 `x+(y-x)/2`,其实这是在自作聪明,题目里根本没告诉你x和y同符号,y-x照样有溢出风险.  
综合前面的情况,我们想到了方案,在判断x和y符号位一致的情况下返回第一个答案,符号位相异的情况下返回第二个答案.答案倒是对了,但着实麻烦,以至于我都懒得写出来.  
用位运算解决这个问题很简单,当然不是`(x+y)>>1`啦,是`(x&y)+(x^y)>>1`.  

第一次见可能觉得不太好理解,思路其实非常直观,它把x和y的二进制补码按位分成两种情况,一种值相同(x和y该位皆为0或者1),一种是相异(x为0、y为1或者x为1、y为0).  
对于值相同的位,(x&y)相当于xy该位之和除2;对于值相异的位,xy该位取异或相当于该位求和,再右移一位相当于除2.两者相加就是平均数.当然这里我没有写出来当值相异时(x&y)为0,以及当值相同时(x^y)也为0,0对加法结果不产生任何影响.  
非常巧妙,感觉画个图更直观,但实在想不出该怎么画才方便.BTW,这个解释绝对原创,若有雷同,那肯定是抄袭我的啦:smile:  

**交换两个数**  
其实不太想讲这个例子,这个例子里边的坑多得蓝瘦,但这又是日常代码里非常容易遇见的情况.  

第一种方案,增加临时变量:  
```c
void swap(int x, int y)
{
  int temp = x;
  x = y;
  y = temp;
}
```
这种方案的弊端就是临时变量占用内存开销.  

第二种方案,采用加减法或者乘除法:
```c
void swap(int x, int y)
{
  x += y;
  y = x - y;
  x -= y;
  /* 下面是乘除法
  x *= y;
  y = x / y;
  x /= y;
  */
}
```
这种方案的弊端是有溢出风险.  

第三种方案,采用异或:
```c
void swap(int x, int y)
{
  x ^= y;
  y ^= x;
  x ^= x;
}
```
这种方案的代码看起来甚是清爽,但是暗藏杀机看出来了吗?  
异或最大的问题是如果两个值相等,异或为0.这种方案在x和y相等的情况下失效.当然,解决也很简单,在代码开头加上判断
```c
void swap(int x, int y)
{
  if(x == y) return;
  x ^= y;
  y ^= x;
  x ^= x;
}
```

以上三种方法都有一个问题,那就是函数的值传递问题,如果在main函数里调用以上的swap函数,传递过来的其实是实参的值,swap函数交换的只是形参,对实参没有任何影响(C语言、Java语言都一样).所以,一般在c语言里边交换函数会这么写:
```c
void swap(int *x, int *y)
{
  int temp = *x;
  *x = *y;
  *y = temp;
}
```
或者这么写:
```c
void swap(int *x,int *y){     
    (*x) ^= (*y) ^= (*x) ^= (*y);     
}  
```
采用指针传递地址,完美地解决了函数值传递的问题.  
还可以采用宏定义
```c
#define SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))
```
当然,还有很多其他方法:sweat_smile:  

**Single Number**  
这是一道[LeetCode](https://leetcode.com/problems/single-number/)上的题:  
给定一个整型数组,除了一个元素外每个元素均出现两次,找出单独的这个元素.  

```java
int singleNumber(int[] nums){  
    int value = 0;  
    for(int i : nums)
        value ^= i;
    return value;  
}  
```
该方案使用Java,如果是Java 8还可以这么写:
```java
int singleNumber(int[] nums){
    return Arrays.stream(nums).reduce(0, (x,y)-> x^y);
}

```
不推荐用Java 8的方式,运行速度慢了许多倍.  
当然这道题蛮简单的,它还有难度偏高的变种题.附上LeetCode的[Bit Manipulation](https://leetcode.com/tag/bit-manipulation/)专题.  

# Epilogue
这里只是简单举了几个例子,其实位运算博大精深,感觉跟数论有点类似,斯坦福有位Sean Eron Anderson教授花了好些年时间收集了不少技巧,不班门弄斧了,附上链接<http://graphics.stanford.edu/~seander/bithacks.html>.  
大家还可以在他的文章找茬,10刀奖励哟,如果直接捐给慈善的话20刀.
